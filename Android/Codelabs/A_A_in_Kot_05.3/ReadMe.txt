https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#0

https://startandroid.ru/ru/courses/architecture-components/27-course/architecture-components/567-urok-34-praktika-todoapp-tasks.html

https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#4

Основы тестирования

Эта кодовая лаборатория охватывает основы запуска и написания тестов для Android. Он включает в себя разработку через тестирование, исходные наборы, Robolectric, AndroidX и тестирование ViewModels и LiveData.

Внедрение зависимостей и тестовые двойники

Эта лаборатория кода описывает, как реализовать ручное внедрение зависимостей и использовать тестовые двойники на Android. Он включает в себя настройку ручного внедрения зависимостей, создание подделок, создание макетов, создание ServiceLocators, инструментальные тесты для фрагментов, тестирование навигации и базовое тестирование Espresso.

Обзор тем тестирования

Эта последняя кодовая лаборатория охватывает тестирование определенных типов кода, в том числе:

Тестирование кода с сопрограммами
Комната для тестирования
Ресурс ожидания для эспрессо
Сквозное тестирование с привязкой данных

Правила JUnit - это классы, в которых вы можете определить общий тестовый код, который может выполняться до, после или во время теста - это способ взять ваш код, который был бы в @Beforeи @After, и поместить его в класс, где он может быть повторно использован.

5. Задача: тестирование синхронизации сопрограмм
На этом этапе вы будете контролировать , как сопрограмма выполняется в тесте с использованием TestCouroutineDispatcher«s pauseDispatcherи resumeDispatcherметоды. Используя эти методы, вы напишете тест для индикатора загрузки вашего StatisticsViewModel.

Напоминаем, что он StatisticViewModelхранит все данные и выполняет все вычисления для экрана статистики :


 05.1: основы тестирования
Эта первая лаборатория кода охватывает основы тестирования на Android, вы напишете свои первые тесты и научитесь тестировать LiveDataи ViewModels.

Вы узнаете о следующих темах:

Как писать и запускать модульные тесты на Android
Как использовать разработку через тестирование
Как выбрать инструментальные тесты и локальные тесты
Вы узнаете о следующих библиотеках и концепциях кода:

JUnit4
Hamcrest
Библиотека тестов AndroidX
Базовая тестовая библиотека компонентов архитектуры AndroidX

Что ты будешь делать
Настраивайте, запускайте и интерпретируйте как локальные, так и инструментальные тесты в Android.
Напишите модульные тесты в Android с помощью JUnit4 и Hamcrest.
Напишите простые LiveDataи ViewModelтесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#3

Шаг 2. Изучите пример кода приложения
Приложение TO-DO основано на популярном образце тестирования и архитектуры Architecture Blueprints (с использованием версии образца с реактивной архитектурой ). Приложение следует архитектуре из Руководства по архитектуре приложения . Он использует ViewModels с фрагментами, репозиторий и комнату. Если вы знакомы с любым из приведенных ниже примеров, это приложение имеет аналогичную архитектуру:

Учебные курсы по основам Android Kotlin
Расширенные обучающие программы для Android
Номер с видом на Codelab
Образец Android Sunflower
Разработка приложений для Android с помощью учебного курса Kotlin Udacity

Более важно, чтобы вы понимали общую архитектуру приложения, чем глубоко разбирались в логике любого отдельного уровня.

Вот список пакетов, которые вы найдете:

Пакет: com.example.android.architecture.blueprints.todoapp

.addedittask

Экран добавления или редактирования задачи: код слоя пользовательского интерфейса для добавления или редактирования задачи.

.data

Уровень данных: это касается уровня данных задач. Он содержит код базы данных, сети и репозитория.

.statistics

Экран статистики: код уровня пользовательского интерфейса для экрана статистики.

.taskdetail

Экран сведений о задаче: код уровня пользовательского интерфейса для отдельной задачи.

.tasks

Экран задач: код уровня пользовательского интерфейса для списка всех задач.

.util

Служебные классы: общие классы, используемые в различных частях приложения, например, для макета обновления смахивания, используемого на нескольких экранах.

Уровень данных (.data)

Это приложение включает смоделированный сетевой уровень в удаленном пакете и уровень базы данных в локальном пакете. Для простоты в этом проекте сетевой уровень моделируется с HashMap задержкой, вместо того, чтобы делать реальные сетевые запросы.

В DefaultTasksRepository координатах или опосредует между сетевым и слоем базы данных и то , что возвращает данные на уровень пользовательского интерфейса.

Слой пользовательского интерфейса (.addedittask, .statistics, .taskdetail, .tasks)

Каждый из пакетов уровня пользовательского интерфейса содержит фрагмент и модель представления, а также любые другие классы, необходимые для пользовательского интерфейса (например, адаптер для списка задач). Это TaskActivity действие, которое содержит все фрагменты.

Навигация

Навигация в приложении управляется компонентом "Навигация" . Это определено в nav_graph.xmlфайле. В моделях представления запускается навигация с помощью Eventкласса; модели представления также определяют, какие аргументы передать. Фрагменты наблюдают за Eventсимволами и выполняют фактическую навигацию между экранами.

Локальные тесты ( исходный набор)test

Эти тесты запускаются локально на JVM вашей машины разработки и не требуют эмулятора или физического устройства. Из-за этого они бегают быстро, но их верность ниже, что означает, что они действуют менее так, как в реальном мире.

В Android Studio локальные тесты представлены значком зеленого и красного треугольника.

Инструментальные тесты ( исходный набор)androidTest

Эти тесты выполняются на реальных или эмулируемых устройствах Android, поэтому они отражают то, что происходит в реальном мире, но также намного медленнее.

В Android Studio инструментальные тесты представлены Android с зеленым и красным треугольником.

Добавьте зависимость Hamcrest
testImplementation "org.hamcrest:hamcrest-all:$hamcrestVersion"

assertEquals(result.completedTasksPercent, 0f)

// versus

assertThat(result.completedTasksPercent, `is`(0f))

 Еще один хороший инструмент для написания удобочитаемых утверждений - это библиотека Truth

7. Задача: написание дополнительных тестов.  Test Driven Development

В этой задаче вы напишете больше тестов, используя JUnit и Hamcrest. Вы также будете писать тесты, используя стратегию, основанную на программной практике разработки через тестирование . Разработка через тестирование или TDD - это школа программирования, которая гласит, что вместо того, чтобы сначала писать код функции, вы сначала пишете свои тесты. Затем вы пишете код функции, чтобы пройти тесты.

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-basics/index.html?index=..%2F..index#7

8. Задача: настройка теста ViewModel с помощью AndroidX Test.

Добавьте ядро AndroidX Test и зависимости ext
Добавить зависимость библиотеки Robolectric Testing
Аннотируйте класс с помощью средства запуска тестов AndroidJunit4
Написать тестовый код AndroidX

9. Задача: написание утверждений для LiveData.

Для проверки LiveDataрекомендуется сделать две вещи:
Использовать InstantTaskExecutorRule
Обеспечить LiveDataнаблюдение

10. Задача: написание нескольких тестов ViewModel.

Совет: в следующих уроках вы узнаете гораздо больше о тестировании ViewModels. Прямо сейчас вы не можете протестировать какие-либо методы в используемой модели представления viewModelScope, вы увидите сообщение об ошибке:

Exception in thread "main" java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize.

Точно так же методы тестирования, которые используются DefaultTaskRepository, сложно, потому что это вызывает код в коде сети и коде базы данных. Все это вы узнаете из следующих лабораторных работ.

12. Резюме
Эта кодовая лаборатория охватывает:

Как запускать тесты из Android Studio.
Разница между локальными ( test) и инструментальными тестами ( androidTest).
Как писать локальные модульные тесты с использованием JUnit и Hamcrest .
Настройка тестов ViewModel с помощью библиотеки тестов AndroidX .

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#0
Расширенный Android в Kotlin 05.2: Введение в тестовые двойники и внедрение зависимостей
Introduction to Test Doubles and Dependency Injection

Эта вторая тестовая кодовая лаборатория посвящена тестовым двойникам: когда их использовать в Android и как их реализовать с помощью внедрения зависимостей, шаблона Service Locator и библиотек. Поступая так, вы научитесь писать:

Модульные тесты репозитория
Интеграционные тесты фрагментов и моделей просмотра
Тесты навигации по фрагментам

Как спланировать стратегию тестирования
Как создавать и использовать тестовые двойники, а именно фейки и моки
Как использовать ручное внедрение зависимостей на Android для модульных и интеграционных тестов
Как применить шаблон Service Locator
Как тестировать репозитории, фрагменты, модели просмотра и компонент навигации

Пирамида тестирования
Когда вы думаете о стратегии тестирования, есть три связанных аспекта тестирования:

Область действия - Какую часть кода затрагивает тест? Тесты могут выполняться одним методом, во всем приложении или где-то посередине.
Скорость - Насколько быстро проходит тест? Скорость тестирования может варьироваться от миллисекунд до нескольких минут.
Верность - Насколько "реальный" тест? Например, если часть тестируемого кода должна выполнить сетевой запрос, действительно ли тестовый код выполняет этот сетевой запрос или подделывает результат? Если тест действительно разговаривает с сетью, это означает, что у него более высокая точность. Компромисс заключается в том, что выполнение теста может занять больше времени, может привести к ошибкам, если сеть не работает, или может быть дорогостоящим в использовании.
Между этими аспектами есть неизбежные компромиссы. Например, скорость и точность - это компромисс: чем быстрее тест, тем меньше точность, и наоборот. Один из распространенных способов разделить автоматизированные тесты - на эти три категории:

Модульные тесты - это узкоспециализированные тесты, которые выполняются в одном классе, обычно в одном методе этого класса. Если модульный тест не проходит, вы можете точно знать, где именно в вашем коде проблема. У них низкая точность, поскольку в реальном мире ваше приложение включает в себя гораздо больше, чем выполнение одного метода или класса. Они достаточно быстрые, чтобы запускаться каждый раз, когда вы меняете код. Чаще всего это тесты, запускаемые локально (в testисходном наборе). Пример: тестирование отдельных методов в моделях представлений и репозиториях.
Интеграционные тесты - тестируют взаимодействие нескольких классов, чтобы убедиться, что при совместном использовании они ведут себя должным образом. Один из способов структурирования интеграционных тестов - это заставить их протестировать одну функцию, например возможность сохранить задачу. Они тестируют больший объем кода, чем модульные тесты, но по-прежнему оптимизированы для быстрой работы, а не для полной точности. Их можно запускать локально или как инструментальные тесты, в зависимости от ситуации. Пример: тестирование всех функциональных возможностей отдельной пары фрагмент и модель представления.
Сквозные тесты (E2e) - проверьте сочетание работающих вместе функций. Они тестируют большие части приложения, тщательно моделируют реальное использование и поэтому обычно работают медленно. Они обладают высочайшей точностью и говорят вам, что ваше приложение действительно работает в целом. По большому счету, эти тесты будут инструментальными тестами (в androidTestисходном наборе). Пример: запуск всего приложения и одновременное тестирование нескольких функций

5. Задача: написать тест с использованием внедрения зависимостей
На этом этапе вы собираетесь использовать технику, называемую ручным внедрением зависимостей, чтобы вы могли использовать только что созданный поддельный тестовый двойник.


7. Задача: использовать фальшивый репозиторий внутри ViewModel.
Tip: To avoid building a seperate factory for each view model, check out the Architecture Blueprints reactive sample, which shows a slightly more complicated version of the tests you are building. It includes a generic ViewModelFactory that can generate any view model needed, and this extension function.
 чтобы не создавать отдельную фабрику для каждой модели представления, ознакомьтесь с реактивным образцом Architecture Blueprints , в котором показана немного более сложная версия тестов, которые вы создаете. Он включает в себя общий ViewModelFactory, который может генерировать любую необходимую модель представления, и эту функцию расширения .
https://github.com/android/architecture-samples/tree/reactive

8. Задача: запустить фрагмент из теста.
Затем вы напишете интеграционные тесты для проверки взаимодействия фрагмента и модели представления. Вы узнаете, правильно ли обновляет код модели представления ваш пользовательский интерфейс. Для этого вы используете

шаблон ServiceLocator
библиотеки Espresso и Mockito

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#8

10. Задача: написание первого интеграционного теста с эспрессо.
Эспрессо помогает:

Взаимодействуйте с представлениями, например нажимая кнопки, перемещая панель или прокручивая экран вниз.
Утверждение, что определенные представления отображаются на экране или находятся в определенном состоянии (например, содержат определенный текст, или что установлен флажок и т. Д.).
Шаг 2. Отключите анимацию.
Тесты эспрессо проводятся на реальном устройстве и, следовательно, по своей природе являются инструментальными тестами. Одна из возникающих проблем - это анимация: если анимация задерживается и вы пытаетесь проверить, отображается ли представление на экране, но оно все еще анимируется, Espresso может случайно не пройти тест. Это может сделать тест на эспрессо нестабильным.


onView(withId(R.id.task_detail_complete_checkbox)).perform(click()).check(matches(isChecked()))
Этот оператор находит представление флажка с идентификатором task_detail_complete_checkbox, щелкает его, а затем утверждает, что он отмечен .

Большинство заявлений об эспрессо состоит из четырех частей:

Статический метод эспрессо
onView

onViewпредставляет собой пример статического метода Espresso, который запускает оператор Espresso. onViewявляется одним из самых распространенных, но есть и другие варианты, например onData.

ViewMatcher
withId(R.id.task_detail_title_text)

withId- это пример объекта, ViewMatcherкоторый получает представление по его идентификатору. Существуют и другие сопоставители представлений, которые вы можете найти в документации .

ViewAction
perform(click())

performМетод , который принимает ViewAction. A ViewAction- это что-то, что можно сделать с представлением, например, здесь это щелчок по представлению.

ViewAssertion
check(matches(isChecked()))

checkкоторый занимает ViewAssertion. ViewAssertions проверяет или утверждает что-то о представлении. Чаще всего ViewAssertionвы будете использовать matchesassertion. Чтобы завершить утверждение ViewMatcher, в данном случае используйте другое isChecked.

Обратите внимание, что вы не всегда вызываете оба performи checkв операторе Espresso. У вас могут быть операторы, которые просто утверждают, используя checkили просто ViewActionиспользуют perform.

11. Задача: использование Mockito для написания тестов навигации.

На этом последнем шаге вы узнаете, как протестировать компонент Navigation , используя другой тип тестового двойника, который называется mock, и библиотеку тестирования Mockito .

Mockito - это фреймворк для создания тестовых двойников. Хотя слово mock используется в API и названии, оно не просто для создания mock. Он также может делать заглушек и шпионов.

13. Резюме
В этой лаборатории кода рассказывалось, как настроить ручную инъекцию зависимостей, локатор сервисов и как использовать фейки и макеты в ваших приложениях Android Kotlin. В частности:

То, что вы хотите протестировать, и ваша стратегия тестирования определяют типы тестов, которые вы собираетесь реализовать для своего приложения. Модульные тесты сфокусированы и быстры. Интеграционные тесты проверяют взаимодействие между частями вашей программы. Сквозные тесты проверяют функции, имеют высочайшую точность, часто оснащены инструментами и могут занять больше времени.
Архитектура вашего приложения влияет на то, насколько сложно его тестировать.
Чтобы изолировать части вашего приложения для тестирования, вы можете использовать тестовые двойники. Двойной тест версия класса созданная специально для тестирования. Например, вы подделываете получение данных из базы данных или Интернета.
Используйте внедрение зависимостей, чтобы заменить реальный класс тестовым классом, например репозиторием или сетевым уровнем.
Используйте инструментальное тестирование ( androidTest) для запуска компонентов пользовательского интерфейса.
Когда вы не можете использовать внедрение зависимостей конструктора, например, для запуска фрагмента, вы часто можете использовать локатор служб. Шаблон Service Locator является альтернативой Dependency Injection. Он включает в себя создание одноэлементного класса под названием «Service Locator», целью которого является предоставление зависимостей как для обычного, так и для тестового кода.

14. Узнать больше
Образцы:

Официальный образец тестирования - это официальный образец тестирования, основанный на том же приложении TO-DO Notes, используемом здесь. Концепции в этом образце выходят за рамки того, что описано в трех тестовых кодовых таблицах.
Демо Sunflower - это основной образец Android Jetpack, который также использует библиотеки тестирования Android.
Образцы для тестирования эспрессо
Курс Udacity:

Разработка приложений для Android с помощью Kotlin
Документация разработчика Android:

Руководство по архитектуре приложения
runBlocking а также runBlockingTest
FragmentScenario
Эспрессо
Mockito
JUnit4
Библиотека тестов AndroidX
Базовая тестовая библиотека компонентов архитектуры AndroidX
Исходные наборы
Тест из командной строки
Внедрение зависимостей на Android
Видео:

Экспертное руководство по внедрению зависимостей на Android (Android Dev Summit '19)
Создание тестируемых приложений для Android (Google I / O'19)
Фрагменты: прошлое, настоящее и будущее (Android Dev Summit '19) - раздел «Тестирование и фрагменты»
Другой:

Использование Dagger в вашем Android-приложении Codelab Tutorial
Тестирование в туалете: знай свои тестовые пары
Руководство по внедрению зависимостей на Android - ADS 2019
Реактивный образец архитектурных чертежей
Кинжал в Котлине: подводные камни и оптимизация
Dagger.dev
https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#13
https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-survey#0
Расширенный Android в Kotlin 05.3: Обзор тем тестирования
Последнее обновление: 20 октября 2020 г.
Сопрограммы, включая сопрограммы с областью видимости модели
Номер
Привязка данных
Сквозные испытания

Вы должны быть знакомы с:

Концепции тестирования, описанные в кодовых таблицах 5.1 «Основы тестирования» и 5.2 «Внедрение зависимостей» и «Тестовые двойники» : написание и запуск модульных тестов на Android с использованием JUnit, Hamcrest, AndroidX test, Robolectric, тестирование LiveData, ручное внедрение зависимостей, тестовые двойники (имитирующие и подделки), Сервисные локаторы, тестирование компонента навигации и эспрессо.
Следующие ядра Android Jetpack библиотеки: view model, LiveData, связывание данных , и в навигации компонент
Архитектура приложения в соответствии с шаблоном из Руководства по архитектуре приложений и кодовых лабораторий Android Fundamentals .
Основы сопрограмм (в том числе ViewModelScope) на Android.
Что ты узнаешь
Как тестировать сопрограммы, включая сопрограммы с областью видимости модели.
Как проверить крайние случаи простых ошибок.
Как протестировать Room.
Как проверить привязку данных с помощью Espresso.
Как писать сквозные тесты.
Как протестировать глобальную навигацию по приложению.
Вы будете использовать:

runBlocking а также runBlockingTest
TestCoroutineDispatcher
pauseDispatcher а также resumeDispatcher
inMemoryDatabaseBuilder
IdlingResource
Что ты будешь делать
Напишите ViewModelинтеграционные тесты, тестирующие код с использованием viewModelScope.
Приостановить и возобновить выполнение сопрограммы для тестирования.
Измените поддельный репозиторий для поддержки тестирования ошибок.
Напишите модульные тесты DAO.
Напишите тесты интеграции с локальным источником данных.
Напишите сквозные тесты, включающие сопрограммы и код привязки данных.
Напишите глобальные тесты навигации приложения.

Шаг 2. Создайте StatisticsViewModelTest
Шаг 3. Создайте тест индикатора загрузки
Когда загружается статистика задачи, приложение отображает индикатор загрузки, который исчезает, как только данные загружаются и статистические расчеты завершаются. Вы напишете тест, который проверяет, что индикатор загрузки отображается во время загрузки статистики, а затем исчезает после загрузки статистики.

refresh()Метод StatisticsViewModel контролирует , когда индикатор нагрузки отображается и исчезает:

6. Задача: проверка обработки ошибок.
7. Задача: испытательная комната.
В какой исходный набор следует поместить тесты базы данных?

Обратите внимание, что, как правило, делайте тесты базы данных инструментальными тестами , то есть они будут в androidTestисходном наборе. Это связано с тем, что если вы запустите эти тесты локально, они будут использовать любую версию SQLite, установленную на вашем локальном компьютере, которая может сильно отличаться от версии SQLite, поставляемой с вашим устройством Android! Различные устройства Android также поставляются с разными версиями SQLite, поэтому также полезно иметь возможность запускать эти тесты как инструментальные тесты на разных устройствах.
Шаг 6. Создайте интеграционный тест для TasksLocalDataSource
8. Задача: Сквозное тестирование с привязкой данных.
До сих пор в этой серии кодовых лабораторий вы писали модульные тесты и интеграционные тесты. Такие интеграционные тесты, как и тесты, TaskDetailFragmentTestориентированы исключительно на тестирование функциональности одного фрагмента, без перехода к другим фрагментам или даже без создания активности. Точно так же TaskLocalDataSourceTestтестирует несколько классов, работающих вместе на уровне данных, но на самом деле не проверяет пользовательский интерфейс.

Сквозные тесты (E2E) тестируют сочетание функций, работающих вместе. Они тестируют большие части приложения и имитируют реальное использование. По большому счету, эти тесты являются инструментальными тестами (в androidTestисходном наборе).

Вот несколько различий между сквозными тестами и интеграционными тестами, относящимися к приложению Todo. E2E тесты:

Запустите приложение с первого экрана.
Создайте актуальную деятельность и репозиторий.
Проверьте совместную работу нескольких фрагментов.
Написание сквозных тестов очень быстро усложняется, и поэтому существует множество инструментов и библиотек, которые упрощают его. Espresso - это библиотека тестирования пользовательского интерфейса Android, обычно используемая для написания сквозных тестов. Вы узнали основы использования эспрессо в предыдущей лабораторной работе .

Важно: эта лабораторная работа предполагает, что вы знакомы с эспрессо. Если вы этого не сделаете, содержимое Espresso в предыдущей лаборатории кода описывает, как писать интеграционные тесты с помощью Espresso.
 Espresso - это библиотека тестирования пользовательского интерфейса Android, обычно используемая для написания сквозных тестов.
Шаг 1. Отключите анимацию
Шаг 2. Создайте TasksActivityTest
Сквозные тесты имитируют работу всего приложения и имитируют реальное использование. Таким образом, вы позволите ServiceLocatorсоздать репозиторий, а не создавать экземпляр репозитория или тестового репозитория самостоятельно:

Создайте свойство под названием репозиторий, которое является TasksRepository.
Создайте @Beforeметод и инициализируйте репозиторий, используя метод ServiceLocator's provideTasksRepository; используйте getApplicationContextдля получения контекста приложения.
В этом @Beforeметоде удалите все задачи в репозитории, чтобы убедиться, что он полностью очищен перед каждым запуском теста.
Создайте @Afterметод , который вызывает ServiceLocator«S resetRepository()метод.

Обратите внимание, что в этом сквозном тесте вы вообще не проверяете интеграцию с репозиторием, контроллером навигации или любыми другими компонентами. Это так называемый тест черного ящика . Предполагается, что тест не должен знать, как что-то реализовано внутри, только результат для данного ввода.
Шаг 7. Используйте wrapEspressoIdlingResource в DefaultTasksRepository

Шаг 9. Используйте ресурсы простоя в тестах

9. Задача: сквозное тестирование навигации по приложениям.
Последний тест, который вы можете сделать, - это проверить навигацию на уровне приложения. Например, тестирование:

Панель навигации
Панель инструментов приложения
Кнопка вверх
Кнопка Назад
Давайте сделаем это сейчас!

Поздравляем с написанием сквозных тестов и завершением этой кодовой лаборатории! Код решения для трех только что написанных тестов находится здесь .

11. Резюме
Эта кодовая лаборатория охватывает:

Обзор тестовых сопрограмм из предыдущих уроков, в том числе описание использования runBlockingversus runBlockingTest.
Как тестировать сопрограммы, viewModelScopeиспользующие TestCoroutineDispatcher
TestCoroutineDispatcherспособность «S к pauseDispatcherи resumeDispatcherконтролировать выполнение сопрограмму
Проверка обработки ошибок обновлением подделки
Тестирование вашего уровня данных, включая ваш DAO и локальный источник данных
Использование IdlingResource(и CountingIldingResourceподкласса) для написания сквозных тестов, которые включают в себя длительный код и работают с библиотекой привязки данных .
Тестирование глобальной навигации приложения в сквозном тесте.

12. Узнать больше
Образцы:

Официальный образец тестирования - это официальный образец тестирования, основанный на том же приложении TO-DO Notes, используемом здесь. Концепции в этом образце выходят за рамки того, что описано в трех тестовых кодовых таблицах.
Демо Sunflower - это основной образец Android Jetpack, который также использует библиотеки тестирования Android.
Образцы для тестирования эспрессо
Курс Udacity:

Разработка приложений для Android с помощью Kotlin
Документация разработчика Android:

Проверьте свою деятельность
Эспрессо
Внедрение зависимостей на Android
Тестовая навигация
Тестирование ваших работников - G1uide по тестированию WorkManager
Видео:

Создание тестируемых приложений для Android (Google I / O'19)
Тестирование сопрограмм на Android (Android Dev Summit '19)
Фрагменты: прошлое, настоящее и будущее (Android Dev Summit '19) - раздел «Тестирование и фрагменты»
Экспертное руководство по внедрению зависимостей на Android (Android Dev Summit '19)
Другой:

Простые сопрограммы в Android: viewModelScope
Тестирование двух последовательных выбросов LiveData в сопрограммах
Тестирование Android с помощью ресурсов ожидания Espresso и тестирование верности
Миграция тестовой комнаты
Использование Dagger в вашем Android-приложении Codelab Tutorial
Руководство по внедрению зависимостей на Android - ADS 2019
Кинжал в Котлине: подводные камни и оптимизация
Dagger.dev

https://codelabs.developers.google.com/codelabs/advanced-android-kotlin-training-testing-survey#11

22.10.2020






